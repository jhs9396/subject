<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.9.2/d3.min.js"></script>
    <script
            src="https://code.jquery.com/jquery-3.4.1.min.js"
            integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
            crossorigin="anonymous"></script>
    <title>Document</title>
</head>
<body>
<div>
    <input type="text" value="156"/><button onclick="clickme()">cluster 반짝</button>
</div>

<svg width="1000" height="1000"></svg>


<script>
    var vertexList = {}
    var edgeList = {}
    var cluster = {}
    var vertexListByLabel = {}
    var cluster_in_view = []

    var svg;


    let xs = d3.scaleOrdinal( d3.range(-100,10000,200))

    let labelArr = ['domain', 'url','email_message','email_address','ip','groups','malware_type','file','location']
    labelArr.forEach(v=>xs(v)) // pattern 에 나온 라벨을 먼저 호출해서 화면 왼쪽부터 배치 되도록


    function oid(o) {
        return o.oid + '.' + o.id
    }

    function findVertexById(id){
        return vertexList[id]
    }

    function drawVertex() {
        svg.selectAll('.vertex').data(Object.values(vertexList))
            .enter()
            .append('circle')
            .attr('class','vertex')
            .attr('r',5)
            .attr('fill','black')
            .attr('cx', d=>{
                d._x = xs(d.label)
                return d._x
            })
            .attr('cy', d=>{
                var idx = vertexListByLabel[d.label].findIndex(dd=> oid(d.id)  == oid(dd.id))
                d._y = 100 + idx * 12
                return d._y
            })
    }

    function updateVertex() {
        svg.selectAll('.vertex').data(Object.values(vertexList))
            .attr('fill',d=>{
                if(d.cluster) {
                    return 'red'
                }else {
                    return 'black'
                }
            })
            // .attr('cy', d=>{
            //     var idx = vertexListByLabel[d.label].findIndex(dd=>d.id == dd.id)
            //     d._y = 100 + idx * 12
            //     return d._y
            // })
            .attr('cy', d=>{
                var idx = vertexListByLabel[d.label].findIndex(dd=> oid(d.id)  == oid(dd.id))
                var clusterIdx = Object.keys(vertexListByLabel).length

                if(d.cluster) {
                    clusterIdx = cluster_in_view.findIndex(dd => d.cluster == dd)
                }

                console.log(clusterIdx,  d.cluster )

                d._y = 100 + idx * 12 + clusterIdx*10
                return d._y
            })

    }

    var link = d3.linkHorizontal()
        .x(function(d) { return d._x; })
        .y(function(d) { return d._y; })
        .source(d=>d._start)
        .target(d=>d._end)


    function drawEdge() {
        svg.selectAll('.edge').data(Object.values(edgeList))
            .enter()
            .append('path')
            .attr('class','edge')
            .attr('stroke', 'gray')
            .attr('stroke-width', '1px')
            .attr('fill', 'none')
            .attr('d', d=>{
                d._start =  findVertexById(d.start.oid + "." + d.start.id)
                d._end =  findVertexById(d.end.oid + "." + d.end.id)

                // console.log(d)

                return link(d)
            })
    }


    function updateEdge() {
        svg.selectAll('.edge').data(Object.values(edgeList))
            .attr('d', d=>{
                // d._start =  findVertexById(d.start.oid + "." + d.start.id)
                // d._end =  findVertexById(d.end.oid + "." + d.end.id)

                return link(d)
            })
    }

    function init(){
        drawVertex()
        drawEdge()
    }



    $(()=>{
        svg = d3.select('svg')

        Promise.all([
            d3.json('./data.json').then(json=>{
                json.map(item=>item.p)
                .map(p=>{
                    p.vertices.forEach(v=>{
                        let id = v.id.oid+'.'+v.id.id;
                        vertexList[id] = v


                        vertexListByLabel[v.label] = vertexListByLabel[v.label] || {}
                        vertexListByLabel[v.label][id] = v


                    })

                    p.edges.forEach(e=>{
                        edgeList[e.id.oid+'.'+e.id.id] = e
                    })
                })

                Object.keys(vertexListByLabel).forEach(k=>{
                    vertexListByLabel[k] = Object.values(vertexListByLabel[k])
                })

                console.log('vertexListByLabel', vertexListByLabel)
            }),
            d3.text('./cluster.dat').then(txt=>{
                var lines = txt.split('\n')
                lines.map(l=>{
                    var cItem = l.split("\t")

                    if(cItem[1]) {
                        cItem[1] = cItem[1].substring(1, cItem[1].length-1).split(",")
                        return cluster[cItem[0]] = cItem[1]
                    }

                })

                console.log(cluster)
            })]
        ).then(init)
    })


    function clickme() {
        var cluster_no = $('input').val()
        console.log('cluster_no', cluster_no, cluster[cluster_no])

        cluster_in_view.push(cluster_no)

        cluster_in_view.sort((a,b)=>a-b)

        let cl_arr = cluster[cluster_no]

        Object.values(vertexList).forEach(v=> {
            // console.log(v)
            let id = v.id.oid + "." + v.id.id
            if(cl_arr.findIndex(x=>x==id) >= 0) {
                v.cluster = cluster_no
                // console.log(v)
            }
        });

        // sort
        Object.keys(vertexListByLabel).forEach(k=>{
            vertexListByLabel[k].sort((a, b)=>{
                if(a.cluster && b.cluster) {
                    return a.cluster - b.cluster
                }else if(a.cluster) {
                    return -1
                }else if(b.cluster) {
                    return 1
                }

                return 0
            })
        })

        updateVertex()
        updateEdge()

    }

</script>

</body>
</html>
